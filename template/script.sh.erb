#!/bin/bash

exec > >(tee -a live_log.log)
exec 2>&1

source .env
# Set defaults to prod if .env is not found
RUN_ENVIRONMENT=${RUN_ENVIRONMENT:-prod}
PROJECT_ROOT=${PROJECT_ROOT:-/srv/scratch/sbf-pipelines/proteinfold}
DB_PATH=${DB_PATH:-/srv/scratch/sbf-pipelines/proteinfold/dbs}
BRANCH=${BRANCH:-master}
REPOSITORY=${REPOSITORY:-Australian-Structural-Biology-Computing/proteinfold}
DEBUGGROUP=${DEBUGGROUP:-sbf}

set -xo pipefail
set -eE

# Define debug directory at the top
NOW=$(date +%Y%m%d_%H%M%S)
RUNNAME="${NOW}_${USER}"

BASE_DEBUGDIR=${BASE_DEBUGDIR:-"/srv/scratch/sbf/debug"}
DEBUGDIR="${BASE_DEBUGDIR}/${RUNNAME}"

BASE_NXF_WORK=${BASE_NXF_WORK:-"/srv/scratch/${USER}/.proteinfold/work"}
export NXF_WORK="${BASE_NXF_WORK}/${RUNNAME}"

BASE_OUT_DIR=${BASE_OUT_DIR:-"/srv/scratch/${USER}/proteinfold_output"}
RUN_DIR=$(echo "<%= context.run_name %>" | sed "s#[^A-Za-z0-9]#_#g")
OUT_DIR="${BASE_OUT_DIR}/${RUN_DIR}"
mkdir -p "${OUT_DIR}"

trap "collect_debug_files" ERR

function collect_debug_files() {
    echo "Error occurred, copying debug files to ${DEBUGDIR}"
    mkdir -p "$DEBUGDIR"
    rsync -a --no-perms --no-owner --no-group --max-size=50m . "${NXF_WORK}" "$DEBUGDIR/"
    find "$DEBUGDIR" -type d -exec chmod 2770 {} +
    find "$DEBUGDIR" -type f -exec chmod 660 {} +
    chgrp "$DEBUGGROUP" -R "$DEBUGDIR"
}

# Set dependency version numbers
VERSION_SAMPLESHEET_UTILS="1.3.4"
source "${PROJECT_ROOT}/${RUN_ENVIRONMENT}/venv/bin/activate"

# Native environment cacheDir used for caching blobs during image pulls
export APPTAINER_CACHEDIR="${APPTAINER_CACHEDIR:-/srv/scratch/${USER}/.images}"
export SINGULARITY_CACHEDIR="${SINGULARITY_CACHEDIR:-/srv/scratch/${USER}/.images}"

# Nextflow variables, checks libraryDir and if image is not found downloads to cache
export NXF_APPTAINER_CACHEDIR="${NXF_APPTAINER_CACHEDIR:-/srv/scratch/${USER}/.images}"
export NXF_SINGULARITY_CACHEDIR="${NXF_SINGULARITY_CACHEDIR:-/srv/scratch/${USER}/.images}"
export NXF_APPTAINER_LIBRARYDIR="${NXF_APPTAINER_LIBRARYDIR:-/srv/scratch/sbf-pipelines/proteinfold/singularity}"
export NXF_SINGULARITY_LIBRARYDIR="${NXF_SINGULARITY_LIBRARYDIR:-/srv/scratch/sbf-pipelines/proteinfold/singularity}"

export PROTEINFOLD_VERSION="2.0.0dev"

mkdir -p "${NXF_WORK}"

function check_depend_version() {
	# Ensure that script is running in prod
	if [ "${RUN_ENVIRONMENT}" == "prod" ]; then
			# Check samplesheet utils
			LOCAL_SAMPLESHEET_VERSION=$(pip3 list 2>&1 | grep samplesheetutils | cut -d' ' -f2)
            if [ "${LOCAL_SAMPLESHEET_VERSION}" != "${VERSION_SAMPLESHEET_UTILS}" ]; then
				echo "VERSION MISMATCH! samplesheet-utils does not match expected version. installed version is ${LOCAL_SAMPLESHEET_VERSION}, expected ${VERSION_SAMPLESHEET_UTILS}"
				exit 1
			fi
	fi
}

check_depend_version

# TODO: This can be handled by institutional nextflow .config allowing for better portability
module purge
module load java/21 nextflow/25

# Check if the input is an amino acid sequence or a path
user_input="<%= context.samplesheet %>"
echo "${user_input}" >> $HOME/debug.txt

MODE=""
[[ "${user_input}" =~ ^[\ A-Z:\*\-]*$ ]] && MODE="MANUAL_INPUT"
[[ "${user_input}" =~ ^.*\.csv$ ]] && MODE="SAMPLESHEET_INPUT"
[[ "${user_input}" =~ ^.*\.(fasta|fa|fas|faa|ffn|fna|frn|yaml|yml|json|txt|seq|aa|pep|protein)$ ]] && MODE="FASTA_INPUT"
[[ "${MODE}" == "" ]] && MODE="DIRECTORY"

echo "${MODE}"

# Validate input file format compatibility with selected method
af_method="<%= context.af_method %>"

# Check YAML/YML compatibility - only supported by Boltz and RoseTTAFold-All-Atom
if [ "${MODE}" == "FASTA_INPUT" ] && [[ "${user_input}" =~ \.(yaml|yml)$ ]]; then
    if [ "${af_method}" != "boltz" ] && [ "${af_method}" != "rosettafold_all_atom" ]; then
        echo "ERROR: YAML/YML input files are only supported by Boltz and RoseTTAFold-All-Atom methods."
        echo "Current method: ${af_method}"
        exit 1
    fi
fi

# Check JSON compatibility - only supported by HelixFold3
if [ "${MODE}" == "FASTA_INPUT" ] && [[ "${user_input}" =~ \.json$ ]]; then
    if [ "${af_method}" != "helixfold3" ]; then
        echo "ERROR: JSON input files are only supported by the HelixFold3 method."
        echo "Current method: ${af_method}"
        exit 1
    fi
fi

# Check directory contents for incompatible file types
if [ "${MODE}" == "DIRECTORY" ] && [ -d "${user_input}" ]; then
    # Check for YAML/YML files in directory
    if [ "${af_method}" != "boltz" ] && [ "${af_method}" != "rosettafold_all_atom" ]; then
        yaml_files=$(find "${user_input}" -type f \( -name "*.yaml" -o -name "*.yml" \) 2>/dev/null || true)
        if [ ! -z "${yaml_files}" ]; then
            echo "ERROR: Directory contains YAML/YML files, which are only supported by Boltz and RoseTTAFold-All-Atom methods."
            echo "Current method: ${af_method}"
            echo "Found YAML/YML files:"
            echo "${yaml_files}"
            exit 1
        fi
    fi

    # Check for JSON files in directory
    if [ "${af_method}" != "helixfold3" ]; then
        json_files=$(find "${user_input}" -type f -name "*.json" 2>/dev/null || true)
        if [ ! -z "${json_files}" ]; then
            echo "ERROR: Directory contains JSON files, which are only supported by the HelixFold3 method."
            echo "Current method: ${af_method}"
            echo "Found JSON files:"
            echo "${json_files}"
            exit 1
        fi
    fi
fi

create-samplesheet --version
SAMPLESHEET=""

af_method="<%= context.af_method %>"
prot_mode="<%= context.prot_mode %>"

# Remap prot_mode if af_method is esmfold and prot_mode is monomer_ptm
if [ "${af_method}" == "esmfold" ] && [ "${prot_mode}" == "monomer_ptm" ]; then
    prot_mode="monomer"
fi

if [ "${af_method}" == "colabfold" ] || [ "${af_method}" == "boltz" ]; then
    case "${prot_mode}" in
        monomer|monomer_ptm)
            prot_mode="alphafold2_ptm"
            ;;
        multimer)
            prot_mode="alphafold2_multimer_v3"
            ;;
    esac
fi

OUTPUT_FORMAT=""
case "${af_method}" in
    helixfold3)  OUTPUT_FORMAT="--json" ;;
    *)    OUTPUT_FORMAT="" ;;
esac

if [ "${MODE}" == "MANUAL_INPUT" ];
then
    create-samplesheet --aa-string "${user_input}" --suffix "${prot_mode}" ${OUTPUT_FORMAT}
    SAMPLESHEET="$(pwd)/samplesheet.csv"
fi

if [ "${MODE}" == "SAMPLESHEET_INPUT" ];
then
    SAMPLESHEET="${user_input}"
fi

if [ "${MODE}" == "FASTA_INPUT" ];
then
    mkdir fasta
    cp "${user_input}" ./fasta/
    create-samplesheet --directory "./fasta" --suffix "${prot_mode}" ${OUTPUT_FORMAT}
    SAMPLESHEET="$(pwd)/samplesheet.csv"
fi

if [ "${MODE}" == "DIRECTORY" ];
then
    mkdir fasta
    working_dir=$(pwd)
    cd "${user_input}"
    for filename in *
    do
        echo "${filename}"
        ln -s "$(pwd)/${filename}" "$working_dir/fasta/$(echo ${filename} | sed --expression='s/\s/\-/g')"
    done

    cd ${working_dir}
    create-samplesheet --directory "./fasta" --suffix "${prot_mode}" ${OUTPUT_FORMAT}
    SAMPLESHEET="$(pwd)/samplesheet.csv"
fi

PROT_MODE=""
ARGS=""

if [ "<%= context.full_dbs %>" == "full" ];
then
    FULL_DB="true"
else
    FULL_DB="false"
fi

if [ "<%= context.msa_server %>" == "local" ];
then
    USE_MSA_SERVER="false"
else
    USE_MSA_SERVER="true"
fi

[[ "<%= context.af_method %>" == "alphafold2"  ]] && PROT_MODE="alphafold2" && ARGS="--alphafold2_db ${DB_PATH} --alphafold2_model_preset ${prot_mode} --alphafold2_full_dbs ${FULL_DB} --alphafold2_mode split_msa_prediction"
[[ "<%= context.af_method %>" == "boltz"  ]] && PROT_MODE="boltz" && ARGS="--boltz_db ${DB_PATH} --colabfold_db ${DB_PATH} --use_msa_server ${USE_MSA_SERVER}"
[[ "<%= context.af_method %>" == "colabfold"   ]] && PROT_MODE="colabfold" && ARGS="--colabfold_db ${DB_PATH} --use_msa_server ${USE_MSA_SERVER} --colabfold_model_preset ${prot_mode}"
[[ "<%= context.af_method %>" == "esmfold" ]] && PROT_MODE="esmfold" && ARGS="--esmfold_db ${DB_PATH} --esmfold_model_preset ${prot_mode}"
[[ "<%= context.af_method %>" == "rosettafold_all_atom" ]] && PROT_MODE="rosettafold_all_atom" && ARGS="--rosettafold_all_atom_db ${DB_PATH}"
[[ "<%= context.af_method %>" == "helixfold3"  ]] && PROT_MODE="helixfold3" && ARGS="--helixfold3_db ${DB_PATH}"

nextflow -c "${PROJECT_ROOT}/kod_proteinfold-${RUN_ENVIRONMENT}.config" run ${REPOSITORY} -r ${BRANCH} -latest \
    --input "${SAMPLESHEET}" \
    --outdir "${OUT_DIR}" \
    --mode "${PROT_MODE}" \
    --use_gpu \
    --monochrome_logs \
    -ansi-log false \
    ${ARGS} \
    -profile apptainer
